Index: src/BulletDynamics/Character/btKinematicCharacterController.h
===================================================================
--- src/BulletDynamics/Character/btKinematicCharacterController.h	(revision 2388)
+++ src/BulletDynamics/Character/btKinematicCharacterController.h	(working copy)
@@ -80,6 +80,7 @@
 	int m_upAxis;
 
 	static btVector3* getUpAxisDirections();
+	bool  m_interpolateUp;
 
 	btVector3 computeReflectionDirection (const btVector3& direction, const btVector3& normal);
 	btVector3 parallelComponent (const btVector3& direction, const btVector3& normal);
@@ -129,7 +130,7 @@
 	virtual void setVelocityForTimeInterval(const btVector3& velocity,
 				btScalar timeInterval);
 
-	void reset ();
+	void reset ( btCollisionWorld* collisionWorld );
 	void warp (const btVector3& origin);
 
 	void preStep (  btCollisionWorld* collisionWorld);
@@ -157,6 +158,7 @@
 	}
 
 	bool onGround () const;
+	void setUpInterpolate (bool value);
 };
 
 #endif // BT_KINEMATIC_CHARACTER_CONTROLLER_H
Index: src/BulletDynamics/Character/btKinematicCharacterController.cpp
===================================================================
--- src/BulletDynamics/Character/btKinematicCharacterController.cpp	(revision 2388)
+++ src/BulletDynamics/Character/btKinematicCharacterController.cpp	(working copy)
@@ -14,6 +14,7 @@
 */
 
 
+#include <stdio.h>
 #include "LinearMath/btIDebugDraw.h"
 #include "BulletCollision/CollisionDispatch/btGhostObject.h"
 #include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
@@ -146,6 +147,7 @@
 	m_jumpSpeed = 10.0; // ?
 	m_wasOnGround = false;
 	m_wasJumping = false;
+	m_interpolateUp = true;
- 	setMaxSlope(btRadians(45.0));
+	setMaxSlope(btRadians(60.0));
 }
 
@@ -246,7 +248,10 @@
 		{
 			// we moved up only a fraction of the step height
 			m_currentStepOffset = m_stepHeight * callback.m_closestHitFraction;
-			m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+			if (m_interpolateUp == true)
+				m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+			else
+				m_currentPosition = m_targetPosition;
 		}
 		m_verticalVelocity = 0.0;
 		m_verticalOffset = 0.0;
@@ -394,9 +399,11 @@
 
 	btScalar downVelocity = (m_verticalVelocity<0.f?-m_verticalVelocity:0.f) * dt;
 	if(downVelocity > 0.0 && downVelocity < m_stepHeight
+	//if(downVelocity > m_fallSpeed
 		&& (m_wasOnGround || !m_wasJumping))
 	{
 		downVelocity = m_stepHeight;
+		//downVelocity = m_fallSpeed;
 	}
 
 	btVector3 step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);
@@ -430,6 +437,16 @@
 	} else {
 		// we dropped the full height
 		
+		downVelocity = (m_verticalVelocity<0.f?-m_verticalVelocity:0.f) * dt;
+		if (downVelocity > m_fallSpeed && (m_wasOnGround || !m_wasJumping))
+		{
+			printf("full\n");
+			m_targetPosition += step_drop; //undo previous target change
+			downVelocity = m_fallSpeed;
+			step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);
+			m_targetPosition -= step_drop;
+		}
+
 		m_currentPosition = m_targetPosition;
 	}
 }
@@ -467,8 +484,21 @@
 
 
 
-void btKinematicCharacterController::reset ()
+void btKinematicCharacterController::reset ( btCollisionWorld* collisionWorld )
 {
+	m_verticalVelocity = 0.0;
+        m_verticalOffset = 0.0;
+        m_wasOnGround = false;
+        m_wasJumping = false;
+        m_walkDirection.setValue(0,0,0);
+        m_velocityTimeInterval = 0.0;
+
+	//clear pair cache
+	btHashedOverlappingPairCache *cache = m_ghostObject->getOverlappingPairCache();
+	while (cache->getOverlappingPairArray().size() > 0)
+	{
+		cache->removeOverlappingPair(cache->getOverlappingPairArray()[0].m_pProxy0, cache->getOverlappingPairArray()[0].m_pProxy1, collisionWorld->getDispatcher());
+	}
 }
 
 void btKinematicCharacterController::warp (const btVector3& origin)
@@ -639,3 +669,9 @@
 void btKinematicCharacterController::debugDraw(btIDebugDraw* debugDrawer)
 {
 }
+
+void btKinematicCharacterController::setUpInterpolate(bool value)
+{
+	m_interpolateUp = value;
+}
+
Index: src/BulletDynamics/Character/btCharacterControllerInterface.h
===================================================================
--- src/BulletDynamics/Character/btCharacterControllerInterface.h	(revision 2388)
+++ src/BulletDynamics/Character/btCharacterControllerInterface.h	(working copy)
@@ -31,7 +31,7 @@
 	
 	virtual void	setWalkDirection(const btVector3& walkDirection) = 0;
 	virtual void	setVelocityForTimeInterval(const btVector3& velocity, btScalar timeInterval) = 0;
-	virtual void	reset () = 0;
+	virtual void	reset ( btCollisionWorld* collisionWorld ) = 0;
 	virtual void	warp (const btVector3& origin) = 0;
 
 	virtual void	preStep ( btCollisionWorld* collisionWorld) = 0;
@@ -40,6 +40,7 @@
 	virtual void	jump () = 0;
 
 	virtual bool	onGround () const = 0;
+	virtual void	setUpInterpolate (bool value) = 0;
 };
 
 #endif //BT_CHARACTER_CONTROLLER_INTERFACE_H
Index: Demos/CharacterDemo/CharacterDemo.cpp
===================================================================
--- Demos/CharacterDemo/CharacterDemo.cpp	(revision 2388)
+++ Demos/CharacterDemo/CharacterDemo.cpp	(working copy)
@@ -341,7 +341,7 @@
 {
 	m_dynamicsWorld->getBroadphase()->getOverlappingPairCache()->cleanProxyFromPairs(m_ghostObject->getBroadphaseHandle(),getDynamicsWorld()->getDispatcher());
 
-	m_character->reset ();
+	m_character->reset (m_dynamicsWorld);
 	///WTF
 	m_character->warp (btVector3(10.210001,-2.0306311,16.576973));
 	
