diff -urN a/src/BulletDynamics/Character/btCharacterControllerInterface.h b/src/BulletDynamics/Character/btCharacterControllerInterface.h
--- a/src/BulletDynamics/Character/btCharacterControllerInterface.h	2013-01-12 22:47:48.526165566 -0600
+++ b/src/BulletDynamics/Character/btCharacterControllerInterface.h	2011-04-28 12:53:37.000000000 -0500
@@ -31,7 +31,7 @@
 	
 	virtual void	setWalkDirection(const btVector3& walkDirection) = 0;
 	virtual void	setVelocityForTimeInterval(const btVector3& velocity, btScalar timeInterval) = 0;
-	virtual void	reset () = 0;
+	virtual void	reset ( btCollisionWorld* collisionWorld ) = 0;
 	virtual void	warp (const btVector3& origin) = 0;
 
 	virtual void	preStep ( btCollisionWorld* collisionWorld) = 0;
@@ -40,6 +40,7 @@
 	virtual void	jump () = 0;
 
 	virtual bool	onGround () const = 0;
+	virtual void	setUpInterpolate (bool value) = 0;
 };
 
 #endif //BT_CHARACTER_CONTROLLER_INTERFACE_H
diff -urN a/src/BulletDynamics/Character/btKinematicCharacterController.cpp b/src/BulletDynamics/Character/btKinematicCharacterController.cpp
--- a/src/BulletDynamics/Character/btKinematicCharacterController.cpp	2013-01-12 22:47:48.526165566 -0600
+++ b/src/BulletDynamics/Character/btKinematicCharacterController.cpp	2013-01-12 22:46:43.652736609 -0600
@@ -14,6 +14,7 @@
 */
 
 
+#include <stdio.h>
 #include "LinearMath/btIDebugDraw.h"
 #include "BulletCollision/CollisionDispatch/btGhostObject.h"
 #include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
@@ -77,6 +78,9 @@
 		if (convexResult.m_hitCollisionObject == m_me)
 			return btScalar(1.0);
 
+		if (!convexResult.m_hitCollisionObject->hasContactResponse())
+			return btScalar(1.0);
+
 		btVector3 hitNormalWorld;
 		if (normalInWorldSpace)
 		{
@@ -146,7 +150,10 @@
 	m_jumpSpeed = 10.0; // ?
 	m_wasOnGround = false;
 	m_wasJumping = false;
+	m_interpolateUp = true;
 	setMaxSlope(btRadians(45.0));
+	m_currentStepOffset = 0;
+	full_drop = false;
 }
 
 btKinematicCharacterController::~btKinematicCharacterController ()
@@ -160,22 +167,22 @@
 
 bool btKinematicCharacterController::recoverFromPenetration ( btCollisionWorld* collisionWorld)
 {
-	// Here we must refresh the overlapping paircache as the penetrating movement itself or the
-	// previous recovery iteration might have used setWorldTransform and pushed us into an object
-	// that is not in the previous cache contents from the last timestep, as will happen if we
-	// are pushed into a new AABB overlap. Unhandled this means the next convex sweep gets stuck.
-	//
-	// Do this by calling the broadphase's setAabb with the moved AABB, this will update the broadphase
-	// paircache and the ghostobject's internal paircache at the same time.    /BW
-
-	btVector3 minAabb, maxAabb;
-	m_convexShape->getAabb(m_ghostObject->getWorldTransform(), minAabb,maxAabb);
-	collisionWorld->getBroadphase()->setAabb(m_ghostObject->getBroadphaseHandle(), 
-						 minAabb, 
-						 maxAabb, 
-						 collisionWorld->getDispatcher());
-						 
-	bool penetration = false;
+        // Here we must refresh the overlapping paircache as the penetrating movement itself or the
+        // previous recovery iteration might have used setWorldTransform and pushed us into an object
+        // that is not in the previous cache contents from the last timestep, as will happen if we
+        // are pushed into a new AABB overlap. Unhandled this means the next convex sweep gets stuck.
+        //
+        // Do this by calling the broadphase's setAabb with the moved AABB, this will update the broadphase
+        // paircache and the ghostobject's internal paircache at the same time.    /BW
+
+        btVector3 minAabb, maxAabb;
+        m_convexShape->getAabb(m_ghostObject->getWorldTransform(), minAabb,maxAabb);
+        collisionWorld->getBroadphase()->setAabb(m_ghostObject->getBroadphaseHandle(),
+                                                 minAabb,
+                                                 maxAabb,
+                                                 collisionWorld->getDispatcher());
+
+        bool penetration = false;
 
 	collisionWorld->getDispatcher()->dispatchAllCollisionPairs(m_ghostObject->getOverlappingPairCache(), collisionWorld->getDispatchInfo(), collisionWorld->getDispatcher());
 
@@ -187,6 +194,12 @@
 		m_manifoldArray.resize(0);
 
 		btBroadphasePair* collisionPair = &m_ghostObject->getOverlappingPairCache()->getOverlappingPairArray()[i];
+
+		btCollisionObject* obj0 = static_cast<btCollisionObject*>(collisionPair->m_pProxy0->m_clientObject);
+                btCollisionObject* obj1 = static_cast<btCollisionObject*>(collisionPair->m_pProxy1->m_clientObject);
+
+		if ((obj0 && !obj0->hasContactResponse()) || (obj1 && !obj1->hasContactResponse()))
+			continue;
 		
 		if (collisionPair->m_algorithm)
 			collisionPair->m_algorithm->getAllContactManifolds(m_manifoldArray);
@@ -260,7 +273,10 @@
 		{
 			// we moved up only a fraction of the step height
 			m_currentStepOffset = m_stepHeight * callback.m_closestHitFraction;
-			m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+			if (m_interpolateUp == true)
+				m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+			else
+				m_currentPosition = m_targetPosition;
 		}
 		m_verticalVelocity = 0.0;
 		m_verticalOffset = 0.0;
@@ -325,7 +341,8 @@
 	{
 		if (m_normalizedDirection.dot(m_touchingNormal) > btScalar(0.0))
 		{
-			updateTargetPositionBasedOnCollision (m_touchingNormal);
+			//interferes with step movement
+			//updateTargetPositionBasedOnCollision (m_touchingNormal);
 		}
 	}
 
@@ -397,7 +414,7 @@
 
 void btKinematicCharacterController::stepDown ( btCollisionWorld* collisionWorld, btScalar dt)
 {
-	btTransform start, end;
+	btTransform start, end, start2, end2;
 
 	// phase 3: down
 	/*btScalar additionalDownStep = (m_wasOnGround && !onGround()) ? m_stepHeight : 0.0;
@@ -407,11 +424,17 @@
 	m_targetPosition -= (step_drop + gravity_drop);*/
 
 	btScalar downVelocity = (m_verticalVelocity<0.f?-m_verticalVelocity:0.f) * dt;
+
+#ifdef BT_USE_DOUBLE_PRECISION
+	if(downVelocity > 0.0 && downVelocity > m_fallSpeed
+		&& (m_wasOnGround || !m_wasJumping))
+		downVelocity = m_fallSpeed;
+
+#else
 	if(downVelocity > 0.0 && downVelocity < m_stepHeight
 		&& (m_wasOnGround || !m_wasJumping))
-	{
 		downVelocity = m_stepHeight;
-	}
+#endif
 
 	btVector3 step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);
 	m_targetPosition -= step_drop;
@@ -419,9 +442,16 @@
 	start.setIdentity ();
 	end.setIdentity ();
 
+	start2.setIdentity ();
+	end2.setIdentity ();
+
 	start.setOrigin (m_currentPosition);
 	end.setOrigin (m_targetPosition);
 
+	//secondary test, with slight offset - this overcomes situations where the standard test misses the polygon due to large polygon rounding errors
+	start2.setOrigin (m_currentPosition - btVector3(0.02, 0.0, 0.02));
+	end2.setOrigin (m_targetPosition- btVector3(0.02, 0.0, 0.02));
+
 	btKinematicClosestNotMeConvexResultCallback callback (m_ghostObject, getUpAxisDirections()[m_upAxis], m_maxSlopeCosine);
 	callback.m_collisionFilterGroup = getGhostObject()->getBroadphaseHandle()->m_collisionFilterGroup;
 	callback.m_collisionFilterMask = getGhostObject()->getBroadphaseHandle()->m_collisionFilterMask;
@@ -429,22 +459,67 @@
 	if (m_useGhostObjectSweepTest)
 	{
 		m_ghostObject->convexSweepTest (m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
+#ifndef BT_USE_DOUBLE_PRECISION
+		if (!callback.hasHit())
+		{
+			//perform second sweep test to prevent check errors
+			m_ghostObject->convexSweepTest (m_convexShape, start2, end2, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
+		}
+#endif
 	} else
 	{
 		collisionWorld->convexSweepTest (m_convexShape, start, end, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
+#ifndef BT_USE_DOUBLE_PRECISION
+		if (!callback.hasHit())
+		{
+			//perform second sweep test to prevent check errors
+			collisionWorld->convexSweepTest (m_convexShape, start2, end2, callback, collisionWorld->getDispatchInfo().m_allowedCcdPenetration);
+		}
+#endif
 	}
 
 	if (callback.hasHit())
 	{
 		// we dropped a fraction of the height -> hit floor
+
+		btScalar fraction = (m_currentPosition.getY() - callback.m_hitPointWorld.getY()) / 2;
+
+		//printf("hitpoint: %g - pos %g\n", callback.m_hitPointWorld.getY(), m_currentPosition.getY());
+
+#ifdef BT_USE_DOUBLE_PRECISION
 		m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+#else
+		if (full_drop == true)
+                        m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, callback.m_closestHitFraction);
+                else
+                        //due to errors in the closestHitFraction variable when used with large polygons, calculate the hit fraction manually
+                        m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, fraction);
+#endif
+		full_drop = false;
+
 		m_verticalVelocity = 0.0;
 		m_verticalOffset = 0.0;
 		m_wasJumping = false;
 	} else {
 		// we dropped the full height
 		
+		full_drop = true;
+
+#ifndef BT_USE_DOUBLE_PRECISION
+		downVelocity = (m_verticalVelocity<0.f?-m_verticalVelocity:0.f) * dt;
+		if (downVelocity > m_fallSpeed && (m_wasOnGround || !m_wasJumping))
+		{
+			m_targetPosition += step_drop; //undo previous target change
+			downVelocity = m_fallSpeed;
+			step_drop = getUpAxisDirections()[m_upAxis] * (m_currentStepOffset + downVelocity);
+			m_targetPosition -= step_drop;
+		}
+#endif
+		//printf("full drop - %g, %g\n", m_currentPosition.getY(), m_targetPosition.getY());
 		m_currentPosition = m_targetPosition;
+
+		//btScalar fraction = (m_currentPosition.getY() - m_targetPosition.getY()) * 2;
+		//m_currentPosition.setInterpolate3 (m_currentPosition, m_targetPosition, fraction);
 	}
 }
 
@@ -479,10 +554,21 @@
 	m_velocityTimeInterval = timeInterval;
 }
 
-
-
-void btKinematicCharacterController::reset ()
+void btKinematicCharacterController::reset ( btCollisionWorld* collisionWorld )
 {
+        m_verticalVelocity = 0.0;
+        m_verticalOffset = 0.0;
+        m_wasOnGround = false;
+        m_wasJumping = false;
+        m_walkDirection.setValue(0,0,0);
+        m_velocityTimeInterval = 0.0;
+
+        //clear pair cache
+        btHashedOverlappingPairCache *cache = m_ghostObject->getOverlappingPairCache();
+        while (cache->getOverlappingPairArray().size() > 0)
+        {
+                cache->removeOverlappingPair(cache->getOverlappingPairArray()[0].m_pProxy0, cache->getOverlappingPairArray()[0].m_pProxy1, collisionWorld->getDispatcher());
+        }
 }
 
 void btKinematicCharacterController::warp (const btVector3& origin)
@@ -653,3 +739,8 @@
 void btKinematicCharacterController::debugDraw(btIDebugDraw* debugDrawer)
 {
 }
+
+void btKinematicCharacterController::setUpInterpolate(bool value)
+{
+	m_interpolateUp = value;
+}
diff -urN a/src/BulletDynamics/Character/btKinematicCharacterController.h b/src/BulletDynamics/Character/btKinematicCharacterController.h
--- a/src/BulletDynamics/Character/btKinematicCharacterController.h	2013-01-12 22:47:48.522165468 -0600
+++ b/src/BulletDynamics/Character/btKinematicCharacterController.h	2012-12-04 15:57:45.616032733 -0600
@@ -81,6 +81,8 @@
 	int m_upAxis;
 
 	static btVector3* getUpAxisDirections();
+	bool  m_interpolateUp;
+	bool  full_drop;
 
 	btVector3 computeReflectionDirection (const btVector3& direction, const btVector3& normal);
 	btVector3 parallelComponent (const btVector3& direction, const btVector3& normal);
@@ -133,7 +135,7 @@
 	virtual void setVelocityForTimeInterval(const btVector3& velocity,
 				btScalar timeInterval);
 
-	void reset ();
+	void reset ( btCollisionWorld* collisionWorld );
 	void warp (const btVector3& origin);
 
 	void preStep (  btCollisionWorld* collisionWorld);
@@ -161,6 +163,7 @@
 	}
 
 	bool onGround () const;
+	void setUpInterpolate (bool value);
 };
 
 #endif // BT_KINEMATIC_CHARACTER_CONTROLLER_H
